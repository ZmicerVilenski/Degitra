// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title Vesting
 */
contract Vesting is ReentrancyGuard, AccessControl {

    // Investor data structure. Mapping from these structures is stored in the contract, it is filled before the start of vesting
    struct InvestorData {
        bool cliffPaid;
        uint8 phaseID; // ID of the vesting phase, for each phase set a unique number
        address investor; // investor address
        uint256 amount; // amount of tokens to be released at the end of the vesting except for amount paid after the cliff
        uint256 released; // amount of tokens released
        uint256 amountAfterCliff; // amount paid after cliff, must be calculated outside the contract from the percentage (cliffPercent)
    }

    // The structure of the vesting phases. Mapping from these structures is stored in the contract, it is filled before the start of vesting
    struct VestingPhase {
        uint32 start; // start time of the vesting period
        uint32 duration; // duration of the vesting period arter cliff in seconds (total duration - cliff)
        uint32 cliff; // cliff period in seconds
        uint32 cliffPercent; // % after cliff period (multiply by 10, because could be fractional percentage, like - 7.5)
        uint32 slicePeriodSeconds; // duration of a slice period in seconds
    }

    // The full structure of vesting in the context of the investor. Not stored in the contract, but returned upon request from the web application
    struct VestingSchedule {
        bool cliffPaid;
        uint8 phaseID; // ID of the vesting phase
        address investor; // investor address
        uint32 cliff; // cliff period in seconds
        uint32 cliffPercent; // % after cliff period (multiply by 10, because could be fractional percentage, like - 7,5)
        // next slot
        uint32 start; // start time of the vesting period
        uint32 duration; // duration of the vesting period arter cliff in seconds
        uint32 slicePeriodSeconds; // duration of a slice period for the vesting in seconds
        // next slots
        uint256 amountAfterCliff; // amount paid after cliff
        uint256 amount; // amount of tokens to be released at the end of the vesting except for percentages after the cliff
        uint256 released; // amount of tokens released exept cliff percent
        uint256 releasedTotal; // total amount of tokens released with cliff percent
        uint256 releasableAmount; // amount of tokens ready for release now
    }

    address public tokenAddress;
    // Create a new role identifier for the admin role
    bytes32 public constant STAGE_ADJUSTMENT_ROLE =
        keccak256("STAGE_ADJUSTMENT_ROLE");
    mapping(bytes32 => InvestorData) private investorsData;
    mapping(uint256 => VestingPhase) private vestingPhases;
    uint256 public vestingTotalAmount;
    mapping(address => uint256) private holdersVestingCount;

    event Released(address indexed investor, uint256 amount);

    /**
     * @dev Reverts if the vesting schedule does not exist or has been revoked.
     */
    modifier onlyIfNotRevoked(bytes32 investorDataId) {
        require(investorsData[investorDataId].amount > 0);
        _;
    }

    /**
     * @dev Throws if called by any accounts other than the SA (stage adjustment) or admin.
     */
    modifier onlyAdminOrSA() {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||
                hasRole(STAGE_ADJUSTMENT_ROLE, msg.sender),
            "Caller is not an admin and has no stage adjustment role"
        );
        _;
    }

    /**
     * @dev Creates a vesting contract.
     * @param _token address of the IERC20/BEP20 token contract
     */
    constructor(address _token) {
        require(_token != address(0x0));
        tokenAddress = IERC20(_token);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev Returns the number of vesting schedules associated to an investor.
     * @return the number of vesting schedules
     */
    function getVestingSchedulesCountByInvestor(address _investor)
        external
        view
        returns (uint256)
    {
        return holdersVestingCount[_investor];
    }

    /**
     * @notice Returns the investor data information for a given holder and index.
     * @return the investor data structure information
     */
    function getInvestorDataByAddressAndIndex(address holder, uint256 index)
        external
        view
        returns (InvestorData memory)
    {
        return
            getInvestorData(
                computeInvestorDataIdForAddressAndIndex(holder, index)
            );
    }

    /**
     * @notice Returns the vesting schedule information for a given holder and index.
     * @return the vesting schedule structure information
     */
    function getVestingScheduleByAddressAndIndex(address holder, uint256 index)
        public
        view
        returns (VestingSchedule memory)
    {
        InvestorData memory investorData = getInvestorData(
            computeInvestorDataIdForAddressAndIndex(holder, index)
        );
        uint256 releasedTotal = investorData.released;
        if (investorData.cliffPaid) {
            releasedTotal = releasedTotal + investorData.amountAfterCliff;
        }
        VestingPhase memory vestingPhase = vestingPhases[investorData.phaseID];
        return
            VestingSchedule(
                investorData.cliffPaid,
                investorData.investor,
                vestingPhase.cliff,
                vestingPhase.cliffPercent,
                investorData.amountAfterCliff,
                vestingPhase.start,
                vestingPhase.duration,
                vestingPhase.slicePeriodSeconds,
                investorData.amount,
                investorData.released,
                releasedTotal,
                _computeReleasableAmount(investorData),
                investorData.phaseID
            );
    }

    /**
     * @notice Returns the array of vesting schedules for a given holder.
     * @return the array of vesting schedule structures
     * @param _investor address of investor
     */
    function getScheduleArrayByInvestor(address _investor)
        external
        view
        returns (VestingSchedule[] memory)
    {
        uint256 vestingSchedulesCount = holdersVestingCount[_investor];
        VestingSchedule[] memory schedulesArray = new VestingSchedule[](
            vestingSchedulesCount
        );
        for (uint256 i = 0; i < vestingSchedulesCount; i++) {
            schedulesArray[i] = getVestingScheduleByAddressAndIndex(
                _investor,
                i
            );
        }
        return schedulesArray;
    }

    /**
     * @notice Creates a new vesting phase.
     * @param _phaseId ID of vesting phase
     * @param _start start time of the vesting period
     * @param _duration duration in seconds of the period in which the tokens will vest
     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest
     * @param _cliffPercent % of token amount could be clamed after the cliff
     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds
     * @param _phaseName name of the vesting phase
     */
    function createVestingPhase(
        uint256_phaseId,
        uint32 _start,
        uint32 _duration,
        uint32 _cliff,
        uint32 _cliffPercent,
        uint32 _slicePeriodSeconds
    ) external onlyAdminOrSA {
        require(_duration >= 0, "Vesting: duration must be >= 0");
        require(
            _slicePeriodSeconds > 0,
            "Vesting: slicePeriodSeconds must be > 0"
        );
        vestingPhases[_phaseId] = VestingPhase(
            _start,
            _duration,
            _start + _cliff,
            _cliffPercent,
            _slicePeriodSeconds
        );
    }

    /**
     * @notice Change vesting phase.
     * @param _phaseId ID of vesting phase
     * @param _start start time of the vesting period
     * @param _duration duration in seconds of the period in which the tokens will vest
     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest
     * @param _cliffPercent % of token amount could be clamed after the cliff
     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds
     * @param _phaseName name of the vesting phase
     */
    function changeVestingPhase(
        uint256 _phaseId,
        uint32 _start,
        uint32 _duration,
        uint32 _cliff,
        uint32 _cliffPercent,
        uint32 _slicePeriodSeconds,
        string memory _phaseName
    ) external onlyAdminOrSA {
        require(_duration > 0, "Vesting: duration must be > 0");
        require(
            _slicePeriodSeconds > 0,
            "Vesting: slicePeriodSeconds must be > 0"
        );
        VestingPhase storage vestingPhase = vestingPhases[_phaseId];
        vestingPhase.start = _start;
        vestingPhase.duration = _duration;
        vestingPhase.cliff = _start + _cliff;
        vestingPhase.cliffPercent = _cliffPercent;
        vestingPhase.slicePeriodSeconds = _slicePeriodSeconds;
    }

    /**
     * @notice Creates a new vesting schedule for an investor.
     * @param _investor address of the investor to whom vested tokens are transferred
     * @param _amount total amount of tokens to be released at the end of the vesting
     * @param _cliffPercent percent from total amount to be payd after cliff
     * @param _phaseID ID of the vesting phase
     */
    function addInvestor(
        uint8 _phaseID,
        address _investor,
        uint256 _amount,
        uint256 _cliffPercent
    ) external onlyAdminOrSA {
        require(_amount > 0, "Vesting: amount must be > 0");
        bytes32 investorDataId = computeNextinvestorDataIdForHolder(_investor);
        uint256 _amountAfterCliff = (_amount * uint256(_cliffPercent)) / 1000;

        investorsData[investorDataId] = InvestorData(
            false,
            _phaseID
            _investor,
            _amount - _amountAfterCliff,
            0,
            _amountAfterCliff
            
        );
        vestingTotalAmount += _amount;
        holdersVestingCount[_investor] += 1;
    }

    /**
     * @notice Cancels an existing schedule by resetting the amount
     * @param investorDataId the vesting schedule identifier
     */
    function cancelInvestorSchedule(bytes32 investorDataId)
        external
        onlyAdminOrSA
    {
        InvestorData storage investorData = investorsData[investorDataId];
        vestingTotalAmount -= ((investorData.amount + investorData.amountAfterCliff) - investorData.released);
        investorData.amount = 0;
        investorData.amountAfterCliff = 0;
        investorData.cliffPaid = true;
    }

    /**
     * @notice Change an existing schedule by overwriting all parameters
     * @param investorDataId the vesting schedule identifier
     * @param _cliffPaid was the amount paid after the cliff
     * @param _amount total amount of tokens to be released at the end of the vesting
     * @param _released how much has already been paid to the investor
     * @param _cliffPercent percent from total amount to be payd after cliff
     * @param _phaseID ID of the vesting phase
     */
    function changeInvestorSchedule(
        bytes32 investorDataId,
        bool _cliffPaid,
        uint256 _amount,
        uint256 _released,
        uint32 _cliffPercent,
        uint8 _phaseID
    ) external onlyAdminOrSA {
        uint256 _amountAfterCliff = (_amount * uint256(_cliffPercent)) / 1000;
        InvestorData storage investorData = investorsData[investorDataId];

        if (_released == 0) {
            _released = investorData.released;
        }
        if (_phaseID == 0) {
            _phaseID = investorData.phaseID;
        }

        vestingTotalAmount -= ((investorData.amount + investorData.amountAfterCliff) - investorData.released);

        investorData.cliffPaid = _cliffPaid;
        investorData.amount = _amount - _amountAfterCliff;
        investorData.released = _released;
        investorData.amountAfterCliff = _amountAfterCliff;
        investorData.phaseID = _phaseID;

        vestingTotalAmount = (vestingTotalAmount + _amount) - _released;
    }

    /**
     * @notice Withdraw the specified amount if possible.
     * @param amount the amount to withdraw
     */
    function withdraw(uint256 amount) external {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Caller is not an admin"
        );
        _safeTransfer(tokenAddress, msg.sender, amount);
    }

    /**
     * @notice Release vested amount of tokens.
     * @param investorDataId the vesting schedule identifier
     * @param amount the amount to release
     */
    function release(bytes32 investorDataId, uint256 amount)
        public
        nonReentrant
        onlyIfNotRevoked(investorDataId)
    {
        InvestorData storage investorData = investorsData[investorDataId];
        require(
            msg.sender == investorData.investor ||
                hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Vesting: only investor and admin can release vested tokens"
        );
        uint256 vestedAmount = _computeReleasableAmount(investorData);
        require(
            vestedAmount >= amount,
            "Vesting: cannot release tokens, not enough vested tokens"
        );
        if (amount != 0) {
            if (investorData.cliffPaid) {
                investorData.released = investorData.released + amount;
            } else {
                investorData.released =
                    (investorData.released + amount) -
                    investorData.amountAfterCliff;
            }
            vestingTotalAmount -= amount;
            investorData.cliffPaid = true;

            _safeTransfer(tokenAddress, payable(investorData.investor), amount);

            emit Released(investorData.investor, amount);
        }
    }

    /**
     * @notice Computes the vested amount of tokens for the given vesting schedule identifier.
     * @return the vested amount
     */
    function computeReleasableAmount(bytes32 investorDataId)
        external
        view
        onlyIfNotRevoked(investorDataId)
        returns (uint256)
    {
        //InvestorData storage investorData = investorsData[investorDataId];
        return _computeReleasableAmount(investorsData[investorDataId]);
    }

    /**
     * @notice Returns the investor data information for a given identifier.
     * @return the investor data structure information
     */
    function getInvestorData(bytes32 investorDataId)
        public
        view
        returns (InvestorData memory)
    {
        return investorsData[investorDataId];
    }

    /**
     * @dev Returns the amount of tokens that can be withdrawn by the admin.
     * @return the amount of tokens
     */
    function getWithdrawableAmount() external view returns (uint256) {
        return _balanceOf(address(this)) - vestingTotalAmount;
        
    }

    /**
     * @dev Computes the next investor data identifier for a given holder address.
     */
    function computeNextinvestorDataIdForHolder(address holder)
        public
        view
        returns (bytes32)
    {
        return
            computeInvestorDataIdForAddressAndIndex(
                holder,
                holdersVestingCount[holder]
            );
    }

    /**
     * @dev Get vesting phase.
     * @param _phaseID ID of phase
     * @return structure of vesting phase
     */
    function getVestingPhase(uint256 _phaseID)
        external
        view
        returns (VestingPhase memory)
    {
        return vestingPhases[_phaseID];
    }

    /**
     * @dev Computes the investor data identifier for an address and an index.
     */
    function computeInvestorDataIdForAddressAndIndex(
        address holder,
        uint256 index
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(holder, index));
    }

    /**
     * @dev Grant the stage adjustment role to a specified account
     * @param saRole_ the address to which SA permissions are set
     */
    function grantSARole(address saRole_) external {
        require(
            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Caller is not an admin"
        );
        _setupRole(STAGE_ADJUSTMENT_ROLE, saRole_);
    }

    /**
     * @dev Computes the releasable amount of tokens for a vesting schedule.
     * @return the amount of releasable tokens
     */
    function _computeReleasableAmount(InvestorData memory investorData)
        internal
        view
        returns (uint256)
    {
        uint32 currentTime = block.timestamp;
        VestingPhase memory vestingPhase = vestingPhases[investorData.phaseID];

        if (
            (currentTime < vestingPhase.cliff) || (investorData.amount == 0) // If cliff not finished or total amount = 0 (schedule was canceled)
        ) {
            return 0;
        } else if (currentTime >= vestingPhase.cliff + vestingPhase.duration) {
            // If vesting period finished
            return investorData.amount - investorData.released;
            // Тут косяк. Если инвестор неразу не забирал в течение вестинг фазы, то сумму возвращает без суммы после клифа
            // Токены инвестор заберет все по итогу, только отображение не корректное и 2 транзакции нужно.
            // В этом случае нужно добавлять amountAfterCliff к возвращаемой сумме и все будет хорошо.
        } else {
            uint32 timeFromStart = currentTime - vestingPhase.cliff;
            uint32 secondsPerSlice = vestingPhase.slicePeriodSeconds;
            uint32 vestedSlicePeriods = timeFromStart / secondsPerSlice;
            uint32 vestedSeconds = vestedSlicePeriods * secondsPerSlice;
            uint256 vestedAmount = (investorData.amount * uint256(vestedSeconds)) / uint256(vestingPhase.duration);
            if (investorData.cliffPaid) {
                vestedAmount = vestedAmount - investorData.released;
            } else {
                vestedAmount = vestedAmount + investorData.amountAfterCliff;
            }
            return vestedAmount;
        }
    }

    function _safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // Transfer selector `bytes4(keccak256(bytes('transfer(address,uint256)')))` should be equal to 0xa9059cbb
        (bool success, bytes memory data) = token.call(
            abi.encodeWithSelector(0xa9059cbb, to, value)
        );
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "TRANSFER_FAILED"
        );
    }

    function _balanceOf(address investor) internal returns(uint) {
        // balanceOf selector `bytes4(keccak256('balanceOf(address)'))` should be equal to 0xa9059cbb
        return token.call(abi.encodeWithSelector(0x70a08231, investor));
    }

}
